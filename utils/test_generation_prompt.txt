### **The LLM Prompt**

**Role:** You are an expert AI data scientist specializing in Natural Language Processing and Information Retrieval.

**Mission:** Your mission is to create a high-quality, synthetic "golden dataset" for evaluating a semantic search system for food. This dataset is crucial for testing the system's ability to understand nuanced, natural language queries in Brazilian Portuguese. You will meticulously generate 100 queries and their corresponding relevance judgments.

**Context & Input Data:**
I will now provide you with a list of 5,000 food item names from a real-world dataset. These are the **only** items you are allowed to use when selecting relevant items for each query.

--- START OF FOOD ITEM LIST ---
**(paste names here)**
--- END OF FOOD ITEM LIST ---

**Your Task in Detail:**

Based on the list above, you will generate a single JSON array containing exactly 100 unique evaluation queries. For each query, you must perform the following steps:

1.  **Craft a Realistic Query:** Create a natural language query in Brazilian Portuguese according to the detailed patterns described below.
2.  **Categorize the Query:** Assign one of the four specified categories to the query.
3.  **Justify the Query:** Briefly explain why this query is a good test case.
4.  **Find and Rank Relevant Items:** Search through the provided list of 5,000 items and select **exactly 15** items that are relevant to the query.
5.  **Assign Relevance Scores:** For each of the 15 items, assign a relevance score based on the criteria provided.
6.  **Justify the Score:** For each item, provide a brief reason for its score.

---

### **1. Query Generation Instructions**

Your generated queries must be diverse and follow these patterns. Create a good mix of all four types.

*   **Specific & Descriptive Dishes:** Combine a base food item with 2-3 specific attributes (Ingredients, Flavors, Textures, Cooking Methods).
    *   *Examples:* "Hambúrguer suculento com queijo cheddar e cebola caramelizada", "Salada crocante com frango grelhado e molho cítrico".
*   **Style & Origin Focus:** Reference a culinary tradition, region, or style.
    *   *Examples:* "Prato típico da culinária baiana", "Massa fresca ao estilo italiano", "Lanche de rua gourmet".
*   **Context & Occasion Focus:** Frame the query around a mealtime, event, or user goal.
    *   *Examples:* "Opção de almoço rápido para o escritório", "Petiscos para compartilhar assistindo futebol", "Jantar leve e saudável".
*   **Abstract & Sensory Focus:** Use subjective, abstract, or sensory language.
    *   *Examples:* "Uma sopa que abraça a alma", "Uma sobremesa impressionante e nostálgica", "Prato robusto e reconfortante para um dia frio".

---

### **2. Relevance Scoring Criteria**

You must assign a relevance score for each of the 15 selected items per query. The scoring criteria are as follows. For each query, try to provide a good mix of scores (e.g., a few 3s, several 2s, and several 1s) to create a challenging and realistic evaluation set.

*   **Score 3 (Perfect Match):** The item is a direct and complete match for the query. It fulfills all explicit and key implicit aspects of the user's request.
    *   *Query:* "Pizza de calabresa com borda recheada" -> *Item:* "Pizza de Calabresa com Borda de Catupiry"
*   **Score 2 (Highly Relevant / Partial Match):** The item is a very good substitute. It matches the core intent and most key attributes of the query but may miss a secondary detail or be a close variation.
    *   *Query:* "Sanduíche de frango grelhado em pão integral" -> *Item:* "Sanduíche de Frango Grelhado" (in a different bread) or "Wrap de Frango Grelhado".
*   **Score 1 (Somewhat Relevant / Topical Match):** The item is in the correct general category but does not match the specific details of the query. It's related but not a close match.
    *   *Query:* "Sanduíche de frango grelhado em pão integral" -> *Item:* "Sanduíche de Carne Assada" or "Salada com Frango".

---

### **3. Required Output Format**

The final output MUST be a single, valid JSON array. It must conform strictly to the following JSON schema. Do not include any text, code comments, or explanations outside of the JSON structure itself.

{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "query_id": { "type": "integer", "description": "A unique integer identifier for the query, starting from 1." },
      "query_text": { "type": "string", "description": "The natural language search query in Brazilian Portuguese." },
      "query_category": { "type": "string", "description": "Category: 'Specific & Descriptive Dishes', 'Style & Origin Focus', 'Context & Occasion Focus', or 'Abstract & Sensory Focus'." },
      "justification": { "type": "string", "description": "Brief explanation in Portuguese of what this query tests." },
      "relevant_items": {
        "type": "array",
        "description": "A list of exactly 15 items from the dataset deemed relevant.",
        "minItems": 15,
        "maxItems": 15,
        "items": {
          "type": "object",
          "properties": {
            "name": { "type": "string", "description": "The exact name of the food item from the provided list." },
            "relevance_score": { "type": "integer", "description": "Score: 3 (perfect), 2 (high), 1 (somewhat).", "minimum": 1, "maximum": 3 },
            "reasoning": { "type": "string", "description": "Brief justification in Portuguese for the assigned score." }
          },
          "required": ["name", "relevance_score", "reasoning"]
        }
      }
    },
    "required": ["query_id", "query_text", "query_category", "justification", "relevant_items"]
  }
}

**Final Instructions:**
*   **Language:** All textual content (`query_text`, `justification`, `reasoning`) must be in **Brazilian Portuguese**.
*   **Source of Items:** You MUST only select items from the provided list of 5,000 names. Do not invent items and give the exact same name.
*   **Strict Quantity:** Generate exactly 100 queries. Each query must have exactly 15 `relevant_items`.
*   **JSON Format:** The entire output must be a single, well-formed JSON array that validates against the provided schema.

Now, begin the generation process. Produce the complete JSON array.